#!/usr/bin/env python

#
# $File: report_progress $
# $LastChangedDate: 2013-04-23 11:58:41 -0500 (Tue, 23 Apr 2013) $
# $Rev: 1855 $
#
# This file is part of variant_tools, a software application to annotate,
# summarize, and filter variants for next-gen sequencing ananlysis.
# Please visit http://varianttools.sourceforge.net for details.
#
# Copyright (C) 2013 Bo Peng (bpeng@mdanderson.org)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

'''
This script analyze passed log files, extract time information for the
execution of pipelines.
'''

import re
import os
import sys
import time
import atexit
import shutil
import subprocess
import tempfile
from datetime import datetime, timedelta
try:
    import argparse
except ImportError:
    sys.exit('Python module argparse (Python 2.7.3+) is required to execute this script')
#
try:
    import matplotlib
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages
    import matplotlib.cm as cm
except ImportError:
    sys.exit('Python module matplotlib is required to execute this script')

class step:
    def __init__(self, name=None, step=None, start_time=None, end_time=None, failed_time=None):
        self.name = name
        self.step = step
        self.start_time = start_time
        self.end_time = end_time
        self.failed_time = failed_time
        self.ongoing_time = None

    def same_step(self, name, step):
        return self.name == name and self.step == int(step)

def extractEpoch(logfile):
    # this marks the start of pipeline (another pattern is 'Executing ...'
    start_pattern = re.compile(r'(\d+-\d+-\d+\s\d+:\d+:\d+),\d+:\sDEBUG:\sINPUT of step\s([a-zA-Z0-9_]+)_(\w+)')
    end_pattern = re.compile(r'(\d+-\d+-\d+\s\d+:\d+:\d+),\d+:\sDEBUG:\sStep\s[^.]+.([a-zA-Z0-9_]+)_(\w+) is executed successfully.')
    failed_pattern = re.compile(r'(\d+-\d+-\d+\s\d+:\d+:\d+),\d+:\sERROR:\sFailed to execute step ([a-zA-Z0-9_]+)_(\w+).')
    # step_times contains tuples of
    # [(pipeline_name, pipeline_number), start_time, end_time, failed_time, on-going time]
    step_times = []
    with open(logfile) as logfile:
        # 
        # 2013-11-25 00:15:50,751: DEBUG: INPUT of step XXXX_YYY
        cur_step = None
        for line in logfile:
            obj = re.match(start_pattern, line)
            # match starting step
            if obj is not None:
                t = datetime.strptime(obj.group(1), "%Y-%m-%d %H:%M:%S")
                # if starts a new step
                if cur_step is not None and not cur_step.same_step(name=obj.group(2), step=obj.group(3)):
                    # if a new pipeline, or a next step, use the new time as ending time
                    if obj.group(2) != cur_step.name or int(obj.group(3)) > cur_step.step:
                        cur_step.end_time = t
                    else:
                        cur_step.failed_time = t
                    step_times.append(cur_step)
                # cur_step recurds step, start_time, completed_time, failed_time, and on-going time
                cur_step = step(name=obj.group(2), step=int(obj.group(3)), start_time=t)
                continue
            # match end of step
            obj = re.match(end_pattern, line)
            if obj is not None:
                t = datetime.strptime(obj.group(1), "%Y-%m-%d %H:%M:%S")
                # completed successfuly
                if cur_step is not None and cur_step.same_step(name=obj.group(2), step=obj.group(3)):
                    cur_step.end_time = t
                    step_times.append(cur_step)
                    # start a new time
                    cur_step = None
                continue
            # match failed step
            obj = re.match(failed_pattern, line)
            if obj is not None:
                t = datetime.strptime(obj.group(1), "%Y-%m-%d %H:%M:%S")
                # same step failed
                if cur_step is not None and cur_step.same_step(name=obj.group(2), step=obj.group(3)):
                    cur_step.failed_time = t
                    step_times.append(cur_step)
                    cur_step = None
        # end of ...
        if cur_step is not None:
            cur_step.ongoing_time = datetime.now()
            step_times.append(cur_step)
    # remove intermediate recovery steps
    return step_times

def retrieveLogFiles(files):
    logfiles = []
    remote_files = [x for x in files if ':' in x]
    if remote_files:
        tdir = tempfile.mkdtemp()
        print('Copying {} to {}'.format(', '.join(remote_files), tdir))
        ret = subprocess.call(['scp'] + remote_files + [tdir])
        logfiles.extend([os.path.join(tdir, x) for x in os.listdir(tdir) if x.endswith('.log')])
        atexit.register(shutil.rmtree, tdir)
    logfiles.extend([f for f in files if os.path.isfile(f)])
    return logfiles


def plotEvents(steps, events):
    start_time = min([min([y.start_time for y in x]) for x in events.values()])
    # the latested completed, failed or start time
    end_time = max([max([max([z for z in (y.start_time, y.end_time, y.failed_time, y.ongoing_time) if z is not None]) for y in x]) for x in events.values()])
    # normalize to seconds
    end_time = start_time + timedelta(seconds=int((end_time - start_time).total_seconds()))
    pad = timedelta(seconds=(end_time - start_time).total_seconds()/40.)
    #
    for name in sorted(events.keys()):
        epochs = events[name]
        print('Drawing figure for log file {}'.format(name))
        plt.figure(figsize=[8, 0.2*len(steps)+2])
        plt.rc('font', size=6)
        plt.plot([], [], '-')
        #plt.grid(True, linestyle=':', color='0.75')
        total_time = (end_time - start_time).total_seconds()
        plt.xlim(start_time - pad, end_time + pad)
        plt.ylim(-1, len(steps))
        plt.yticks(range(len(steps)), ['{}-{}'.format(x,y) for x,y in steps], fontsize=5)
        plt.xlabel('Time', fontsize=5)
        plt.ylabel('Steps')
        plt.plot([start_time, start_time], [-1, 0], '-', color='black', linewidth=0.5)
        plt.text(start_time, -0.8, ' {}'.format(start_time), fontsize=5)
        plt.text(start_time + timedelta(seconds=int((end_time - start_time).total_seconds()/2.)), -0.8,
            '{} '.format(timedelta(seconds=int((end_time - start_time).total_seconds()))), fontsize=5, ha='center')
        plt.plot([end_time, end_time], [-1, 0], '-', color='black', linewidth=0.5)
        plt.text(end_time, -0.8, '{} '.format(end_time), fontsize=5, ha='right')
        plt.gcf().autofmt_xdate()
        #plt.xticks([0, 1], ['0', '1'], fontsize=8)
        plt.title(name.rsplit('.', 1)[0])
        for epo in epochs:
            step = steps.index((epo.name, epo.step))
            y = [step, step]
            x = [epo.start_time, epo.start_time]
            if epo.failed_time is not None:
                style = '-'
                x = [epo.start_time, epo.failed_time]
                c = 'red'
                plt.plot([epo.failed_time], [step], 'ro')
            elif epo.end_time is not None:
                style = '-'
                x = [epo.start_time, epo.end_time]
                duration = epo.end_time-epo.start_time
                if duration.total_seconds() > total_time / 20:
                    plt.text(epo.start_time, y[0] + 0.2, duration, fontsize=5)
                c = 'green'
            elif epo.ongoing_time is not None:
                style = '-'
                x = [epo.start_time, epo.ongoing_time]
                duration = epo.ongoing_time - epo.start_time
                duration = timedelta(seconds=int(duration.total_seconds()))
                if duration.total_seconds() > total_time / 20:
                    plt.text(epo.start_time, y[0] + 0.2, duration, fontsize=5, color='purple')
                c = 'purple'
            else:  # unknown
                style = '-'
                x = [epo.start_time, epo.start_time]
                c = 'purple'
            plt.plot(x, y, style, color=c)
    print('Figures saved to {}'.format(filename))


def plotEventSummary(output, steps, events):
    jobs = sorted(events.keys())
    # the earliest start time
    start_time = min([min([y.start_time for y in x]) for x in events.values()])
    # the latested completed, failed or start time
    end_time = max([max([max([z for z in (y.start_time, y.end_time, y.failed_time, y.ongoing_time) if z is not None]) for y in x]) for x in events.values()])
    # normalize to seconds
    end_time = start_time + timedelta(seconds=int((end_time - start_time).total_seconds()))
    pad = timedelta(seconds=(end_time - start_time).total_seconds()/40.)
    #
    plt.rc('font', size=6)
    plt.subplots_adjust(left=0.2, right=0.95, top=0.90, bottom=0.05)
    plt.plot([], [], '-')
    plt.grid(True, linestyle=':', color='0.75')
    total_time = (end_time - start_time).total_seconds()
    plt.xlim(start_time - pad, end_time + pad)
    plt.ylim(-1, len(jobs))
    plt.yticks(range(len(jobs)), [x.rsplit('.', 1)[0] for x in jobs], fontsize=6)
    plt.xlabel('Time')
    plt.ylabel('Jobs')
    plt.plot([start_time, start_time], [-1, 0], '-', color='black', linewidth=0.5)
    plt.text(start_time, -0.8, ' {}'.format(start_time), fontsize=6)
    plt.text(start_time + timedelta(seconds=int((end_time - start_time).total_seconds()/2.)), -0.8,
        '{} '.format(timedelta(seconds=int((end_time - start_time).total_seconds()))), fontsize=6, ha='center')
    plt.plot([end_time, end_time], [-1, 0], '-', color='black', linewidth=0.5)
    plt.text(end_time, -0.8, '{} '.format(end_time), fontsize=6, ha='right')
    plt.gcf().autofmt_xdate()
    #plt.xticks([0, 1], ['0', '1'], fontsize=8)
    plt.title('Progress of {} jobs'.format(len(jobs)))
    # get all possible steps
    all_steps = []
    for e in events.values():
        all_steps.extend([(epo.name, epo.step) for epo in e])
    all_steps = sorted(list(set(all_steps)))
    colors = ['blue', 'green', 'cyan', 'magenta', 'yellow']
    for name in jobs:
        idx = jobs.index(name)
        epochs = events[name]
        for epo in epochs:
            step = steps.index((epo.name, epo.step))
            y = [idx, idx]
            x = [epo.start_time, epo.start_time]
            if epo.failed_time is not None:
                style = '-'
                x = [epo.start_time, epo.failed_time]
                duration = epo.failed_time - epo.start_time
                c = colors[all_steps.index((epo.name, epo.step)) % len(colors)]
                bw = 0.15
                plt.fill_between(x, [k-0.25 for k in y], [k+0.25 for k in y], color='red')
            elif epo.end_time is not None:
                style = '-'
                x = [epo.start_time, epo.end_time]
                duration = epo.end_time-epo.start_time
                c = colors[all_steps.index((epo.name, epo.step)) % len(colors)]
                bw = 0.45
            elif epo.ongoing_time is not None:
                style = '-'
                x = [epo.start_time, epo.ongoing_time]
                duration = epo.ongoing_time - epo.start_time
                duration = timedelta(seconds=int(duration.total_seconds()))
                c = colors[all_steps.index((epo.name, epo.step)) % len(colors)]
                bw = 0.05
            else:  # unknown
                style = '-'
                x = [epo.start_time, epo.start_time]
                duration = 0
                c = 'white'
                bw = 0
            #plt.plot(x, y, style, color=c)
            if duration.total_seconds() > total_time / 20:
                plt.text(epo.start_time + duration/2, y[0], epo.step, ha='center', va='center', fontsize=5)
            plt.fill_between(x, [k-bw for k in y], [k+bw for k in y], color=c)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='''This script reads one or
        more local or remote log files produces by variant tools, extract
        starting times of steps of pipelines, and generate graphical reports''')
    parser.add_argument('logfiles', nargs='+',
        help='''One or more log files. If address:path is specified, log files
            will be copied to a temporary directory using command scp. No
            password can be specified so public key authentication is needed
            if a password is needed.''')
    parser.add_argument('--output', default='progress.pdf',
        help='''Name of the output file (in pdf format). progress.pdf will be 
            used if no file is specified.''')
    parser.add_argument('--separated', default=False, action='store_true',
        help='''Plot separate figures for each jobs''')
    parser.add_argument('--update', type=int,
        help='''If an interval is given (in seconds), keep the figure on screen
            and update it automatically for every such seconds.''')
    parser.add_argument('--scale', type=int, default=1,
        help='''Scale up the figure when it is displayed on screen. ''')
    #
    args = parser.parse_args()
    #
    while True:
        steps = set()
        events = {}
        for logfile in retrieveLogFiles(args.logfiles):
            e = extractEpoch(logfile)
            if e:
                steps |= set([(x.name, x.step) for x in e])
                events[os.path.split(logfile)[-1]] = e
        #
        pp = PdfPages(args.output)
        if args.update:
            fig = plt.figure(1, figsize=[8, 0.2*len(events)+2], dpi=args.scale * 100)
            fig.patch.set_facecolor('white')
        else:
            fig = plt.figure(1, figsize=[8, 0.2*len(events)+2])
        if args.separated and not args.update:
            plotEvents(args.output, list(sorted(steps)), events)
        else:
            plotEventSummary(args.output, list(sorted(steps)), events)
        print('Figures saved to {}'.format(args.output))
        pp.savefig()
        pp.close()
        if args.update:
            plt.draw()
            plt.show(block=False)
            time.sleep(args.update)
        else:
            break

