#!/usr/bin/env python

#
# $File: report_progress $
# $LastChangedDate: 2013-04-23 11:58:41 -0500 (Tue, 23 Apr 2013) $
# $Rev: 1855 $
#
# This file is part of variant_tools, a software application to annotate,
# summarize, and filter variants for next-gen sequencing ananlysis.
# Please visit http://varianttools.sourceforge.net for details.
#
# Copyright (C) 2013 Bo Peng (bpeng@mdanderson.org)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

'''
This script analyze passed log files, extract time information for the
execution of pipelines.
'''

import re
import os
import sys
import time
import atexit
import shutil
import subprocess
import tempfile
from datetime import datetime
try:
    import argparse
except ImportError:
    sys.exit('Python module argparse (Python 2.7.3+) is required to execute this script')
#
try:
    import matplotlib
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages
    import matplotlib.cm as cm
except ImportError:
    sys.exit('Python module matplotlib is required to execute this script')

def extractEpoch(logfile):
    # this marks the start of pipeline (another pattern is 'Executing ...'
    start_pattern = re.compile(r'(\d+-\d+-\d+\s\d+:\d+:\d+),\d+:\sDEBUG:\sINPUT of step\s([^_]+)_(\w+)')
    end_pattern = re.compile(r'(\d+-\d+-\d+\s\d+:\d+:\d+),\d+:\sDEBUG:\sStep\s[^.].([^_]+)_(\w+) is executed successfully.')
    failed_pattern = re.compile(r'(\d+-\d+-\d+\s\d+:\d+:\d+),\d+:\sDEBUG:\sFailed to execute\s[^.].([^_]+)_(\w+).')
    #
    step_times = []
    with open(logfile) as logfile:
        # 
        # 2013-11-25 00:15:50,751: DEBUG: INPUT of step XXXX_YYY
        cur_step = None
        for line in logfile:
            obj = re.match(start_pattern, line)
            if obj is not None:
                t = datetime.strptime(obj.group(1), "%Y-%m-%d %H:%M:%S")
                # if starts a new time, and not closed...
                if cur_step is not None and (obj.group(2), int(obj.group(3))) != cur_step[0]:
                    # if a new pipeline, or a next step, use the new time as ending time
                    if obj.group(2) != cur_step[0][0]:
                        cur_step[2] = t
                    elif int(obj.group(3)) > cur_step[0][1]:
                        cur_step[2] = t
                    else:
                        cur_step[3] = t
                    step_times.append(cur_step)
                # cur_step recurds step, start_time, completed_time, and failed_time
                cur_step = [(obj.group(2), int(obj.group(3))), t, None, None]
                continue
            obj = re.match(end_pattern, line)
            if obj is not None:
                t = datetime.strptime(obj.group(1), "%Y-%m-%d %H:%M:%S")
                # completed successfuly
                if cur_step is not None and (obj.group(2), int(obj.group(3))) != cur_step[0]:
                    cur_step[2] = t
                    step_times.append(cur_step)
                    cur_step = None
                continue
            obj = re.match(failed_pattern, line)
            if obj is not None:
                t = datetime.strptime(obj.group(1), "%Y-%m-%d %H:%M:%S")
                # completed successfuly
                if cur_step is not None and (obj.group(2), int(obj.group(3))) != cur_step[0]:
                    cur_step[3] = t
                    step_times.append(cur_step)
                    cur_step = None
    # remove intermediate recovery steps
    return step_times # [x for x in step_times if x[2] is None or (x[2] - x[1]).total_seconds() > 20]


def retrieveLogFiles(files):
    logfiles = []
    for f in files:
        if os.path.isfile(f):
            logfiles.append(f)
        elif ':' in f:
            tdir = tempfile.mkdtemp()
            print('Copying {} to {}'.format(f, tdir))
            ret = subprocess.call(['scp', f, tdir])
            if ret != 0:
                raise RuntimeError('Failed to copy files from {}'.format(f))
            logfiles.extend([os.path.join(tdir, x) for x in os.listdir(tdir) if x.endswith('.log')])
            atexit.register(shutil.rmtree, tdir)
    return logfiles
            
    
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='''This script reads one or
        more local or remote log files produces by variant tools, extract
        starting times of steps of pipelines, and generate graphical reports''')
    parser.add_argument('logfiles', nargs='+',
        help='''One or more log files. If address:path is specified, log files
            will be copied to a temporary directory using command rcp. No
            password can be specified so public key authentication is needed
            if a password is needed.''')
    parser.add_argument('--output', default='progress.pdf',
        help='''Name of the output file (in pdf format). progress.pdf will be 
            used if no file is specified.''')
    #
    args = parser.parse_args()
    #
    steps = set()
    events = {}
    for logfile in retrieveLogFiles(args.logfiles):
        e = extractEpoch(logfile)
        if e:
            steps |= set([x[0] for x in e])
            events[os.path.split(logfile)[-1]] = e
    #
    pipelines = set([x[0] for x in steps])
    # the earliest start time
    start_time = min([min([y[1] for y in x]) for x in events.values()])
    # the latested completed, failed or start time
    end_time = max([max([y[2] if y[2] is not None else (y[3] if y[3] is not None else y[1]) for y in x]) for x in events.values()])
    steps = list(sorted(steps))
    print('{} steps for piplines {} from {} to {} are identified'.format(
        len(steps), ', '.join(sorted(pipelines)), start_time, end_time))
    #
    #fig, ax = plt.subplots()
    filename = args.output if args.output.endswith('.pdf') else args.output + '.pdf'
    pp = PdfPages(filename)
    for name, epochs in events.items():
        print('Drawing figure for log file {}'.format(name))
        plt.figure()
        plt.rc('font', size=8)
        plt.plot([], [], '-')
        plt.grid(True, linestyle=':', color='0.75')
        plt.xlim(start_time, end_time)
        plt.ylim(0, len(steps))
        plt.yticks(range(len(steps)), ['{}-{}'.format(x,y) for x,y in steps], fontsize=8)
        plt.xlabel('Time')
        plt.ylabel('Steps')
        plt.gcf().autofmt_xdate()
        #plt.xticks([0, 1], ['0', '1'], fontsize=8)
        plt.title(name)
        for item, start, end, failed in epochs:
            step = steps.index(item)
            y = [step, step]
            x = [start, start]
            if failed is not None:
                style = '-'
                x = [start, failed]
                c = 'red'
            elif end is not None:
                style = '-'
                x = [start, end]
                duration = end-start
                if duration.total_seconds() > 120:
                    plt.text(start, y[0] + 0.2, duration, fontsize=5)
                c = 'green'
            else:  # unknown
                style = '-'
                x = [start, start]
                c = 'purple'
            plt.plot(x, y, style, color=c)
        pp.savefig()
    pp.close()
    print('Figures saved to {}'.format(filename))

