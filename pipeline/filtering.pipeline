# Copyright (C) 2013 Bo Peng (bpeng@mdanderson.org)
# Distributed under GPL. see <http://www.gnu.org/licenses/>
#
# Please refer to http://varianttools.sourceforge.net/Pipeline/New for
# a description of the format of this file.

[pipeline description]
description=Pipelines to filter variants.

denovo_description=This pipeline identifies de novo mutations from a
  family of unaffected parents, affected offspring, and optional unaffected
  siblings. It can be applied either to the current project (no --input is
  specified), or a snapshot (--input) for which the snapshot will be loaded
  and overwrite the existing project. The parameter --samples is required to
  specify the name of samples in the order of parents, offspring (proband),
  and sibling. Parameter --name is recommended to give all variant tables
  a prefix. This pipeline will produce tables $name_denovo (variants
  that are observed only in the proband), $name_denovo_by_site
  (variants that are observed in the proband with no variant in parents and
  sibling at this site). And, depending on values of parameter
  --databases, it can produce tables $table_1kg for variants in 1000 genomes
  project, $table_dbSNP for variants in dbSNP project, and $table_refGene, 
  $table_refGene_exon, $table_ccdsGene, $table_ccdsGene_exon, $table_CancerGenomeCensus,
  $table_COSMIC, $table_dbNSFP, $table_phastCons, $table_phastConsElements,
  $table_genomicSuperDups for tables in respective annotation databases. It is
  up to you to select variants based on these membership tables using the
  'vtools compare' command. Two optional output files are allowed. The first
  one is a log file to which a summary report will be appended. The project
  will be saved to a snapshot if a name (or filename with extension .tar or
  .tar.gz) is specified as the second output.

recessive_description=This pipeline identifies recessive mutations from a
  family of unaffected parents, affected offspring, and optional unaffected
  siblings. Recessive variant is defined as variants that are homozygous in
  the affected offspring (proband), heterozygous in both parents, and
  heterozygous or wildtype in a sibling (if available). The pipeline 
  can be applied either to the current project (no --input is
  specified), or a snapshot (--input) for which the snapshot will be loaded
  and overwrite the existing project. The parameter --samples is required to
  specify the name of samples in the order of parents, offspring (proband),
  and sibling. Parameter --name is recommended to give all variant tables
  a prefix. This pipeline will produce tables $name_recessive (variants
  that are observed only in the proband), $name_recessive_by_site
  (variants that are observed in the proband with no variant in parents and
  sibling at this site). And, depending on values of parameter
  --databases, it can produce tables $table_1kg for variants in 1000 genomes
  project, $table_dbSNP for variants in dbSNP project, and $table_refGene, 
  $table_refGene_exon, $table_ccdsGene, $table_ccdsGene_exon, $table_CancerGenomeCensus,
  $table_COSMIC, $table_dbNSFP, $table_phastCons, $table_phastConsElements,
  $table_genomicSuperDups for tables in respective annotation databases. It is
  up to you to select variants based on these membership tables using the
  'vtools compare' command.  Two optional output files are allowed. The first
  one is a log file to which a summary report will be appended. The project
  will be saved to a snapshot if a name (or filename with extension .tar or
  .tar.gz) is specified as the second output.
  

# exon_novel_hg19_description=This pipeline 1) removes all variants from the
#   thousand genomes project,
#   2) removes variants that are in duplicated regions, 3) removes variants that
#   are not in phastCons46ways conserved regions, and 4) removes variants that are
#   not in exonic regions of UCSC ref genes. The source and result variant tables
#   can be specified by parameters --source_table and --dest_table. The pipeline
#   can be applied to the existing project (no --input is required), or a snapshot
#   (provided to --input, project in the current folder will be overwritten). If
#   an output file is specified, variants will be exported in csv format, with 
#   annotation fields refGene.name2 (gene name), dbSNP name and function estimate,
#   SIFT and PolyPhen2 scores and prediction, phastCons scores for highly conserved
#   regions (phastConsElements), and all sample genotypes (0 for wildtype, 1 for
#   heterozygote, 2 for homozygote). Additional fields such as quality
#   score could be specified via option --extra_export_fields 
# 
# 
# #cancer_gene_description=This pipeline selects variants in genes listed in
# #  cancer gene census 
# 
[DEFAULT]

samples=
samples_comment=Name of samples for parents, offspring (proband), and sibling
  for the denovo and recessive pipelines.

name=family
name_comment=Name of the family. All generated tables will be prefixed with
  this name.

databases=thousandGenomes,dbSNP,refGene,ccdsGene,refGene_exon,ccdsGene_exon,CosmicCodingMuts,CosmicNonCodingVariants,dbNSFP,phastCons,phastConsElements,genomicSuperDups
databases_comment=Databases for which membership tables will be produced.

[denovo_0]
# if there is CMD_INPUT, treat it as a snapshot, otherwise take the project
# database as step input
input=${CMD_INPUT: CMD_INPUT if CMD_INPUT else glob.glob('*.proj')}
input_emitter=EmitInput(select=${INPUT0: not INPUT0[0].endswith('.proj')})
action=RunCommand(cmd='vtools admin --load_snapshot ${CMD_INPUT}')
comment=Load specified snapshot if a snapshot is specified. Otherwise use the
   existing project.

PAR1=${:"%(samples)s".split(',')[0]}
PAR2=${:'%(samples)s'.split(',')[1]}
PROBAND=${:'%(samples)s'.split(',')[2]}
SIBLING=${:'%(samples)s'.split(',')[3] if len('%(samples)s'.split())>3 else ''}

[denovo_5]
action=CheckVariantToolsVersion('2.2.1')
comment=Check the version of variant tools (version 2.2.1 and above is required
    to execute this pipeline)

[denovo_10]
action=RunCommand(cmd=[
    '''vtools select variant --samples "sample_name = '${PAR1}'"
        --to_table "%(name)s_${PAR1}" "variants from sample ${PAR1}" ''' ,
    '''vtools select variant --samples "sample_name = '${PAR2}'" 
        --to_table "%(name)s_${PAR2}" "variants from sample ${PAR2}" ''',
    '''vtools select variant --samples "sample_name = '${PROBAND}'"
        --to_table "%(name)s_${PROBAND}" "variants from sample ${PROBAND}" ''']
    + ([
      '''vtools select variant --samples "sample_name = '${SIBLING}'" 
        --to_table "%(name)s_${SIBLING}" "variants from sample ${SIBLING}" '''
    ] if '${SIBLING}' else []))
comment=Select variants for each sample


[denovo_15]
action=RunCommand(cmd=[
    'vtools use ' + x for x in '%(databases)s'.split(',')
    ])
comment=Import all annotation databases

[denovo_20]
action=RunCommand(cmd=[
    '''vtools compare "%(name)s_${PROBAND}" "%(name)s_${PAR1}" "%(name)s_${PAR2}" "%(name)s_${SIBLING}" 
    --difference "%(name)s_denovo" "de novo variants for family %(name)s" '''
    if '${SIBLING}' else
    '''vtools compare "%(name)s_${PROBAND}" "%(name)s_${PAR1}" "%(name)s_${PAR2}" 
    --difference "%(name)s_denovo" 
    "de novo variants for family %(name)s " '''
    ])
comment=Locate de novo variants of the proband


[denovo_30]
action=RunCommand(cmd=[
    '''vtools compare "%(name)s_${PROBAND}" "%(name)s_${PAR1}" "%(name)s_${PAR2}" "%(name)s_${SIBLING}"
    --mode site 
    --difference "%(name)s_denovo_by_site" "de novo variants for family %(name)s(by site, namely no parental variant at the sites)" '''
    if '${SIBLING}' else
    '''vtools compare "%(name)s_${PROBAND}" "%(name)s_${PAR1}" "%(name)s_${PAR2}" 
    --mode site 
    --difference "%(name)s_denovo_by_site" "de novo variants for family %(name)s (by site, namely no parental and sibling variant at the sites)" '''
    ])
comment=Locate de novo variants by site (no parental variants at the sites, even if
    the variants are different). This table contains a subset of table $name_denovo.


[denovo_50]
action=RunCommand(cmd=[
    '''vtools select "%(name)s_denovo" "%%s.chr IS NOT NULL" 
    --to_table "%(name)s_denovo_in_%%s" "de novo variants in database %%s"''' %% (x, x, x)
    for x in [os.path.basename(z).split('.')[0] for z in '%(databases)s'.split(',')]
    ])
comment=Create variant tables according to their membership in different annotation databases

[denovo_100]
input_emitter=EmitInput(select=${CMD_OUTPUT: len(CMD_OUTPUT)>0})
action=RunCommand(cmd=[
    r"printf '\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    r"printf 'SUMMARY: Identification of de novo variants for family %(name)s\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    r"printf '\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    r"printf 'Members:\n${PAR1} ${PAR2} (unaffected parents), ${PROBAND} (affected offspring)" + 
    ("${SIBLING} (unaffected sibling)\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}\n" if '${SIBLING}' else "\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}"),
    r"printf '\nNumber of variants:\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    r"printf '${:projInfo(tables=['%(name)s_${PAR1}', '%(name)s_${PAR2}', '%(name)s_${PROBAND}'] + (['%(name)s_${SIBLING}'] if '${SIBLING}' else []))}\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    ] + [
    r"printf '\nde novo variants:\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    r"printf '${:projInfo(tables=['%(name)s_denovo', '%(name)s_denovo_by_site'])}\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    r"printf '\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    r"printf 'Database membership:\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    ] + 
    [ r'''printf '${:projInfo(tables=["%(name)s_denovo_in_%%s"  %% x
        for x in [os.path.basename(z).split('.')[0] for z in '%(databases)s'.split(',')]]
    )}\n'  >> ${CMD_OUTPUT: CMD_OUTPUT[0]}''' ]
  )
comment=Summarize the results.


[denovo_200]
input_emitter=EmitInput(select=${CMD_OUTPUT: len(CMD_OUTPUT)>1})
action=RunCommand(cmd='''vtools admin --save_snapshot "${CMD_OUTPUT:CMD_OUTPUT[1]}" 
  "snapshot after identification of de novo variants for family %(name)s" ''')
comment=Save the project to a snapshot if an output is specified.


[recessive_0]
# if there is CMD_INPUT, treat it as a snapshot, otherwise take the project
# database as step input
input=${CMD_INPUT: CMD_INPUT if CMD_INPUT else glob.glob('*.proj')}
input_emitter=EmitInput(select=${INPUT0: not INPUT0[0].endswith('.proj')})
action=RunCommand(cmd='vtools admin --load_snapshot ${CMD_INPUT}')
comment=Load specified snapshot if a snapshot is specified. Otherwise use the
   existing project.

PAR1=${:"%(samples)s".split(',')[0]}
PAR2=${:'%(samples)s'.split(',')[1]}
PROBAND=${:'%(samples)s'.split(',')[2]}
SIBLING=${:'%(samples)s'.split(',')[3] if len('%(samples)s'.split())>3 else ''}

[recessive_5]
action=CheckVariantToolsVersion('2.2.1')
comment=Check the version of variant tools (version 2.2.1 and above is required
    to execute this pipeline)

[recessive_10]
action=RunCommand(cmd=[
    '''vtools update variant --from_stat "%(name)s_par_het=#(het)" --samples "sample_name in ('${PAR1}', '${PAR2}')" ''',
    '''vtools update variant --from_stat "%(name)s_proband_hom=#(hom)" --samples "sample_name = '${PROBAND}'" ''']
    + ([
    '''vtools update variant --from_stat "%(name)s_sib_hom=#(hom)" --samples "sample_name = '${SIBLING}'" ''',
    ] if '${SIBLING}' else []))
comment=Count the number of heterozygotes in parents, number of homozygotes in proband and
    his or her sibling, if available.

[recessive_15]
action=RunCommand(cmd=[
    'vtools use ' + x for x in '%(databases)s'.split(',')
    ])
comment=Import all annotation databases


[recessive_20]
action=RunCommand(cmd=[
    '''vtools select variant "%(name)s_par_het=2" "%(name)s_proband_hom=1" "%(name)s_sib_hom=0" 
        --to_table "%(name)s_recessive" "Recessive variants (homozygous in proband, heterozygous or wildtype in parents and sibling)" '''
    if '${SIBLING}' else
    '''vtools select variant "%(name)s_par_het=2" "%(name)s_proband_hom=1" 
        --to_table "%(name)s_recessive" "Recessive variants (homozygous in proband, heterozygous in parents)" '''
    ])
comment=Locate recessive variants of the proband (homozygous only in proband)
  and save variants in table $name_recessive


[recessive_50]
action=RunCommand(cmd=[
    '''vtools select "%(name)s_recessive" "%%s.chr IS NOT NULL" 
    --to_table "%(name)s_recessive_in_%%s" "recessive variants in database %%s"''' %% (x, x, x)
    for x in [os.path.basename(z).split('.')[0] for z in '%(databases)s'.split(',')]
    ])
comment=Create variant tables according to their membership in different annotation databases

[recessive_100]
input_emitter=EmitInput(select=${CMD_OUTPUT: len(CMD_OUTPUT)>0})
action=RunCommand(cmd=[
    r"printf '\n'>> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    r"printf 'SUMMARY: Identification of recessive variants for family %(name)s\n'  >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    r"printf '\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    r"printf 'Members:\n${PAR1} ${PAR2} (unaffected parents), ${PROBAND} (affected offspring)" + 
    ("${SIBLING} (unaffected sibling)\n'  >> ${CMD_OUTPUT: CMD_OUTPUT[0]}\n" if '${SIBLING}' else "\n'  >> ${CMD_OUTPUT: CMD_OUTPUT[0]}"),
    r"printf '\nNumber of variants:\n'  >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    r"printf '${:projInfo(tables=['%(name)s_${PAR1}', '%(name)s_${PAR2}', '%(name)s_${PROBAND}'] + (['%(name)s_${SIBLING}'] if '${SIBLING}' else []))}\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    ] + [
    r"printf '\nRecessive variants:\n'  >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    r"printf '${:projInfo(tables='%(name)s_recessive')}\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    r"printf '\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    r"printf 'Database membership:\n' >> ${CMD_OUTPUT: CMD_OUTPUT[0]}",
    ] + 
    [ r'''printf '${:projInfo(tables=["%(name)s_recessive_in_%%s"  %% x
        for x in [os.path.basename(z).split('.')[0] for z in '%(databases)s'.split(',')]]
    )}\n'  >> ${CMD_OUTPUT: CMD_OUTPUT[0]}''' ]
  )
comment=Summarize the results.

[recessive_200]
input_emitter=EmitInput(select=${CMD_OUTPUT: len(CMD_OUTPUT)>1})
action=RunCommand(cmd='''vtools admin --save_snapshot "${CMD_OUTPUT:CMD_OUTPUT[1]}"
    "snapshot after identification of recessive variants for family %(name)s" ''')
comment=Save the project to a snapshot if an output is specified.


