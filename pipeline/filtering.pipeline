# Copyright (C) 2013 Bo Peng (bpeng@mdanderson.org)
# Distributed under GPL. see <http://www.gnu.org/licenses/>
#
# Please refer to http://varianttools.sourceforge.net/Pipeline/New for
# a description of the format of this file.

[pipeline description]
description=Pipelines to filter variants.

denovo_description=This pipeline identifies de novo mutations from a
  family of unaffected parents, affected offspring, and optional unaffected
  siblings. It can be applied either to the current project (no --input is
  specified), or a snapshot (--input) for which the snapshot will be loaded
  and overwrite the existing project. The parameter --samples is required to
  specify the name of samples in the order of parents, offspring (proband),
  and sibling. Parameter --name is recommended to give all variant tables
  a prefix. This pipeline will produce tables $name_denovo (variants
  that are observed only in the proband), $name_denovo_by_site
  (variants that are observed in the proband with no variant in parents and
  sibling at this site). And, depending on values of parameter
  --databases, it can produce tables $table_1kg for variants in 1000 genomes
  project, $table_dbSNP for variants in dbSNP project, and $table_refGene, 
  $table_refGene_exon, $table_ccdsGene, $table_ccdsGene_exon, $table_CancerGenomeCensus,
  $table_COSMIC, $table_dbNSFP, $table_phastCons, $table_phastConsElements,
  $table_genomicSuperDups for tables in respective annotation databases. It is
  up to you to select variants based on these membership tables using the
  'vtools compare' command. 


recessive_description=This pipeline identifies recessive mutations from a
  family of unaffected parents, affected offspring, and optional unaffected
  siblings. Recessive variant is defined as variants that are homozygous in
  the affected offspring (proband), heterozygous in both parents, and
  heterozygous or wildtype in a sibling (if available). The pipeline 
  can be applied either to the current project (no --input is
  specified), or a snapshot (--input) for which the snapshot will be loaded
  and overwrite the existing project. The parameter --samples is required to
  specify the name of samples in the order of parents, offspring (proband),
  and sibling. Parameter --name is recommended to give all variant tables
  a prefix. This pipeline will produce tables $name_recessive (variants
  that are observed only in the proband), $name_recessive_by_site
  (variants that are observed in the proband with no variant in parents and
  sibling at this site). And, depending on values of parameter
  --databases, it can produce tables $table_1kg for variants in 1000 genomes
  project, $table_dbSNP for variants in dbSNP project, and $table_refGene, 
  $table_refGene_exon, $table_ccdsGene, $table_ccdsGene_exon, $table_CancerGenomeCensus,
  $table_COSMIC, $table_dbNSFP, $table_phastCons, $table_phastConsElements,
  $table_genomicSuperDups for tables in respective annotation databases. It is
  up to you to select variants based on these membership tables using the
  'vtools compare' command. 



# exon_novel_hg19_description=This pipeline 1) removes all variants from the
#   thousand genomes project,
#   2) removes variants that are in duplicated regions, 3) removes variants that
#   are not in phastCons46ways conserved regions, and 4) removes variants that are
#   not in exonic regions of UCSC ref genes. The source and result variant tables
#   can be specified by parameters --source_table and --dest_table. The pipeline
#   can be applied to the existing project (no --input is required), or a snapshot
#   (provided to --input, project in the current folder will be overwritten). If
#   an output file is specified, variants will be exported in csv format, with 
#   annotation fields refGene.name2 (gene name), dbSNP name and function estimate,
#   SIFT and PolyPhen2 scores and prediction, phastCons scores for highly conserved
#   regions (phastConsElements), and all sample genotypes (0 for wildtype, 1 for
#   heterozygote, 2 for homozygote). Additional fields such as quality
#   score could be specified via option --extra_export_fields 
# 
# 
# #cancer_gene_description=This pipeline selects variants in genes listed in
# #  cancer gene census 
# 
[DEFAULT]

samples=
samples_comment=Name of samples for parents, offspring (proband), and sibling
  for the denovo and recessive pipelines.

name=family
name_comment=Name of the family. All generated tables will be prefixed with
  this name.

databases=thousandGenomes,dbSNP,refGene,ccdsGene,refGene_exon,ccdsGene_exon,CosmicCodingMuts,CosmicNonCodingVariants,dbNSFP,phastCons,phastConsElements,genomicSuperDups
databases_comment=Databases for which membership tables will be produced.

[denovo_0]
# if there is CMD_INPUT, treat it as a snapshot, otherwise take the project
# database as step input
input=${CMD_INPUT: CMD_INPUT if CMD_INPUT else glob.glob('*.proj')}
input_emitter=EmitInput(select=${INPUT0: not INPUT0[0].endswith('.proj')})
action=RunCommand(cmd='vtools admin --load_snapshot ${CMD_INPUT}')
comment=Load specified snapshot if a snapshot is specified. Otherwise use the
   existing project.

PAR1=${:"%(samples)s".split(',')[0]}
PAR2=${:'%(samples)s'.split(',')[1]}
PROBAND=${:'%(samples)s'.split(',')[2]}
SIBLING=${:'%(samples)s'.split(',')[3] if len('%(samples)s'.split())>3 else ''}

[denovo_10]
action=RunCommand(cmd=[
    '''vtools select variant --samples "sample_name = '${PAR1}'"
        --to_table "%(name)s_${PAR1}" "variants from sample ${PAR1}" ''' ,
    '''vtools select variant --samples "sample_name = '${PAR2}'" 
        --to_table "%(name)s_${PAR2}" "variants from sample ${PAR2}" ''',
    '''vtools select variant --samples "sample_name = '${PROBAND}'"
        --to_table "%(name)s_${PROBAND}" "variants from sample ${PROBAND}" ''']
    + ([
      '''vtools select variant --samples "sample_name = '${SIBLING}'" 
        --to_table "%(name)s_${SIBLING}" "variants from sample ${SIBLING}" '''
    ] if '${SIBLING}' else []))
comment=Select variants for each sample

[denovo_20]
action=RunCommand(cmd=[
    '''vtools compare "%(name)s_${PROBAND}" "%(name)s_${PAR1}" "%(name)s_${PAR2}" "%(name)s_${SIBLING}" 
    --difference "%(name)s_denovo" "de novo variants for family %(name)s" '''
    if '${SIBLING}' else
    '''vtools compare "%(name)s_${PROBAND}" "%(name)s_${PAR1}" "%(name)s_${PAR2}" 
    --difference "%(name)s_denovo" 
    "de novo variants for family %(name)s " '''
    ])
comment=Locate de novo variants of the proband

[denovo_30]
action=RunCommand(cmd=[
    '''vtools compare "%(name)s_${PROBAND}" "%(name)s_${PAR1}" "%(name)s_${PAR2}" "%(name)s_${SIBLING}"
    --mode site 
    --difference "%(name)s_denovo_by_site" "de novo variants for family %(name)s(by site, namely no parental variant at the sites)" '''
    if '${SIBLING}' else
    '''vtools compare "%(name)s_${PROBAND}" "%(name)s_${PAR1}" "%(name)s_${PAR2}" 
    --mode site 
    --difference "%(name)s_denovo_by_site" "de novo variants for family %(name)s (by site, namely no parental and sibling variant at the sites)" '''
    ])
comment=Locate de novo variants by site (no parental variants at the sites, even if
    the variants are different). This table contains a subset of table $name_denovo.

[denovo_40]
action=RunCommand(cmd=[
    'vtools use ' + x for x in '%(databases)s'.split(',')
    ])
comment=Import all annotation databases

[denovo_50]
action=RunCommand(cmd=[
    '''vtools select "%(name)s_denovo" "%%s.chr IS NOT NULL" 
    --to_table "%(name)s_denovo_in_%%s" "de novo variants in database %%s"''' %% (x, x, x)
    for x in [os.path.basename(z).split('.')[0] for z in '%(databases)s'.split(',')]
    ])
comment=Create variant tables according to their membership in different annotation databases



[recessive_0]
# if there is CMD_INPUT, treat it as a snapshot, otherwise take the project
# database as step input
input=${CMD_INPUT: CMD_INPUT if CMD_INPUT else glob.glob('*.proj')}
input_emitter=EmitInput(select=${INPUT0: not INPUT0[0].endswith('.proj')})
action=RunCommand(cmd='vtools admin --load_snapshot ${CMD_INPUT}')
comment=Load specified snapshot if a snapshot is specified. Otherwise use the
   existing project.

PAR1=${:"%(samples)s".split(',')[0]}
PAR2=${:'%(samples)s'.split(',')[1]}
PROBAND=${:'%(samples)s'.split(',')[2]}
SIBLING=${:'%(samples)s'.split(',')[3] if len('%(samples)s'.split())>3 else ''}

[recessive_10]
action=RunCommand(cmd=[
    '''vtools update variant --from_stat "%(name)s_par_het=#(het)" --samples "sample_name in ('${PAR1}', '${PAR2}')" ''',
    '''vtools update variant --from_stat "%(name)s_proband_hom=#(hom)" --samples "sample_name = '${PROBAND}'" ''']
    + ([
    '''vtools update variant --from_stat "%(name)s_sib_hom=#(hom)" --samples "sample_name = '${SIBLING}'" ''',
    ] if '${SIBLING}' else []))
comment=Count the number of heterozygotes in parents, number of homozygotes in proband and
    his or her sibling, if available.

[recessive_20]
action=RunCommand(cmd=[
    '''vtools select variant "%(name)s_par_het=2" "%(name)s_proband_hom=1" "%(name)s_sib_hom=0" 
        --to_table "%(name)s_recessive" "Recessive variants (homozygous in proband, heterozygous or wildtype in parents and sibling)" '''
    if '${SIBLING}' else
    '''vtools select variant "%(name)s_par_het=2" "%(name)s_proband_hom=1" 
        --to_table "%(name)s_recessive" "Recessive variants (homozygous in proband, heterozygous in parents)" '''
    ])
comment=Locate recessive variants of the proband (homozygous only in proband)
  and save variants in table $name_recessive

[recessive_40]
action=RunCommand(cmd=[
    'vtools use ' + x for x in '%(databases)s'.split(',')
    ])
comment=Import all annotation databases

[recessive_50]
action=RunCommand(cmd=[
    '''vtools select "%(name)s_recessive" "%%s.chr IS NOT NULL" 
    --to_table "%(name)s_recessive_in_%%s" "recessive variants in database %%s"''' %% (x, x, x)
    for x in [os.path.basename(z).split('.')[0] for z in '%(databases)s'.split(',')]
    ])
comment=Create variant tables according to their membership in different annotation databases



#   vtools update variant --from_stat 'DID5141_HetP=#(het)' --samples "sample_name in ('WGS3_2', 'WGS3_3')"
#   vtools update variant --from_stat 'DID5141_HomO=#(hom)' --samples "sample_name = 'WGS3_1'"
  
# 
# source_table=variant
# source_table_comment=Variant table at the beginning of the filtering process
# 
# dest_table=exon_novel_hg19
# dest_table_comment=Variant table at the end of the filtering process
# 
# prefix=exon_novel
# prefix_comment=A prefix for all intermediate variant tables
# 
# extra_export_fields=
# extra_export_fields_comment=Additional export fields such as quality score
# 
# [exon_novel_hg19_0]
# # if there is CMD_INPUT, treat it as a snapshot, otherwise take the project
# # database as step input
# input=${CMD_INPUT: CMD_INPUT if CMD_INPUT else glob.glob('*.proj')}
# input_emitter=EmitInput(select=${INPUT0: not INPUT0[0].endswith('.proj')})
# action=RunCommand(cmd='vtools admin --load_snapshot ${CMD_INPUT}')
# comment=Load specified snapshot if a snapshot is specified. Otherwise use the
#   existing project.
# 
# [exon_novel_hg19_10]
# # input: CMD_INPUT or project file
# # output: cache/_0.info
# action=RunCommand(cmd=[
# 	'vtools show table %(source_table)s > ${CACHE_DIR}/%(prefix)s_1.info'],
# 	output="${CACHE_DIR}/%(prefix)s_1.info")
# comment=Retrieve information of source variant table.
# 
# [exon_novel_hg19_20]
# action=RunCommand(cmd=[
# 	'vtools use thousandGenomes',
# 	'vtools select %(source_table)s "thousandGenomes.chr IS NULL OR thousandGenomes.SCS_INFO > 3"
# 		-t "%(prefix)s_2" "With variants in 1000 genomes, but with those that are probably pathogenic"',
# 	'vtools show table %(prefix)s_2 > ${CACHE_DIR}/%(prefix)s_2.info'],
# 	output="${CACHE_DIR}/%(prefix)s_2.info")
# comment=Remove variants that are in 1000 genomes, but keep those with 
#   SCS_INFO > 3 (probably pathogenic)
# 
# [exon_novel_hg19_30]
# action=RunCommand(cmd=[
# 	'vtools use genomicSuperDups',
# 	'vtools select %(prefix)s_2 "genomicSuperDups.chr IS NULL"
# 		-t "%(prefix)s_3" "Remove variants in duplicated regions."',
# 	'vtools show table %(prefix)s_3 > ${CACHE_DIR}/%(prefix)s_3.info'],
# 	output="${CACHE_DIR}/%(prefix)s_3.info")
# comment=Remove variants in duplicated regions
# 
# [exon_novel_hg19_40]
# action=RunCommand(cmd=[
# 	'vtools use phastCons',
# 	'vtools select %(prefix)s_3 "phastCons.chr IS NOT NULL"
# 		-t "%(prefix)s_4" "Keep variants in conserved regions."',
# 	'vtools show table %(prefix)s_4 > ${CACHE_DIR}/%(prefix)s_4.info'],
# 	output="${CACHE_DIR}/%(prefix)s_4.info")
# comment=Remove variants that are not in conserved regions
# 
# [exon_novel_hg19_50]
# action=RunCommand(cmd=[
# 	'vtools use refGene_exon',
# 	'vtools select %(prefix)s_4 "refGene_exon.chr IS NOT NULL"
# 		-t "%(dest_table)s" "Keep variants in exonic regions of UCSC ref seq genes"',
# 	'vtools show table %(dest_table)s > ${CACHE_DIR}/%(dest_table)s.info'],
# 	output="${CACHE_DIR}/%(dest_table)s.info")
# comment=Remove variants not in exonic regions of UCSC ref seq genes and 
#   create a variant table specified by parameter --dest_table (default to
#   exon_novel_hg19).
# 
# [exon_novel_hg19_60]
# action=RunCommand(cmd=[
#     'vtools use dbNSFP',
#     'vtools use phastConsElements',
#     'vtools export %(dest_table)s --format csv --samples 1 
#         --fields chr pos ref alt dbSNP.name refGene.name2
#           dbNSFP.SIFT_score dbNSFP.Polyphen2_HDIV_score
#           Polyphen2_HDIV_pred Polyphen2_HVAR_score Polyphen2_HVAR_pred
#           phastConsElements.score dbSNP.func %(extra_export_fields)s
#         --order_by chr pos 
#         --header chr pos ref alt rsname Gene
#           "SIFT score (<0.05 for damaging)" "Polyphen2 HDIV score"
#           "Polyphen2 HDIV prediction"  "Polyphen2 HVAR score"  "Polyphen2 HVAR prediction"
#           "phastCons score" "dbSNP func code" %(extra_export_fields)s "%%(sample_names)s"
#         > ${CMD_OUTPUT} '
#     ],
#     output="${CMD_OUTPUT}")
# input_emitter=EmitInput(select=${CMD_OUTPUT: bool(CMD_OUTPUT)})
# comment=Output selected variants in csv format
# 
# 
