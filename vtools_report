#!/usr/bin/env python2.7
#
# $File: vtools_report $
# $LastChangedDate: 2011-06-16 20:10:41 -0500 (Thu, 16 Jun 2011) $
# $Rev: 4234 $
#
# This file is part of variant_tools, a software application to annotate,
# summarize, and filter variants for next-gen sequencing ananlysis.
# Please visit http://variant_tools.sourceforge.net # for details.
#
# Copyright (C) 2004 - 2010 Bo Peng (bpeng@mdanderson.org)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

import sys, os
import argparse
import subprocess
import logging

#
# These functions are utility functions used by all reports
#
def addVerbosityArg(parser):
    parser.add_argument('-v', '--verbosity', default='0', choices=['0','1','2'],
        help='''Output error and warning (0), info (1) and debug (2) information
            of vtools and vtools_report. Debug information are always recorded
            in project and vtools_report log files.''')

# global logger object, which will be set by getLogger() when the script
# is executed. 
verbosity = '1'
logger = None

def getLogger():
    # create a logger
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)
    # output to standard output
    cout = logging.StreamHandler()
    levels = {
        None: logging.INFO,
        '0': logging.ERROR,
        '1': logging.INFO,
        '2': logging.DEBUG
        }
    #
    cout.setLevel(levels[verbosity])
    cout.setFormatter(logging.Formatter('%(levelname)s: %(message)s'))
    logger.addHandler(cout)
    # output to a log file vtools_report.log
    ch = logging.FileHandler('vtools_report.log', mode='a')
    ch.setLevel(logging.DEBUG)
    ch.setFormatter(logging.Formatter('%(asctime)s: %(levelname)s: %(message)s'))
    logger.addHandler(ch)
    return logger


def getoutput(cmd):
    # add -v option if unspecified
    if True not in [x.startswith('-v') for x in cmd]:
        cmd.append('-v{}'.format(verbosity))
    # call vtools and return its output
    logger.info(' '.join([x if (x.isalnum() or x.startswith('-')) else '"' + x.replace('"', '\"') + '"' for x in cmd]))
    # '.' is added to $PATH so that command (vtools) that is in the current directory
    # can be executed.
    return subprocess.check_output(cmd, env={'PATH': os.pathsep.join(['.', os.environ['PATH']])}).strip()

#
# These functions call vtools to extract information that are needed by other
# reports.
#
def getNumOfSamples():
    # FIXME: should we rely on SELECT COUNT(1) FROM sample?
    logger.info('Getting number of samples')
    return int(getoutput(['vtools', 'execute', 'SELECT count(1) FROM sample']))

def getSamples(samples, group_by=[]):
    '''return a generator that returns samples group by group. To use this functions, call it like
    for group, IDs in getSamples(condi, group_by):
        # do something with group and IDs.
    '''
    output = getoutput(['vtools', 'execute', 'SELECT {} FROM sample LEFT OUTER JOIN filename ON sample.file_id = filename.file_id {} {};'\
        .format('sample_id, {}'.format(', '.join(group_by)) if group_by else 'sample_id',
            'WHERE {}'.format(' AND '.join(samples)) if samples else '',
            'GROUP BY {}'.format(', '.join(group_by)) if group_by else '')]).split('\n')
    # we return results batch by batch as a generator
    IDs = []
    group = ()
    for line in output:
        fields = [x.strip() for x in line.split(',')]
        ID = fields[0]
        g = tuple(fields[1:])
        if group == ():
            group = g
        if g == group:
            IDs.append(ID)
        else:
            yield (group, IDs)
            # start a new group
            group = g
            IDs = [ID]
    yield (group, IDs)

#
# Command trans_ratio
#
def transRatioArguments(parser):
    parser.add_argument('-n', '--num_field', required=True,
        help='''Name of the field that holds sample variant count, which is the field name for
            command 'vtools sample_stat --num FIELD_NAME'.''')
    parser.add_argument('--by_count', action='store_true',
        help='Output transition/transversion rate for each sample variant frequency (count) group')
    parser.add_argument('table', 
        help='''Variant table for which transversion/transversion mutants are counted.''')

def transRatio(args):
    out = sys.stdout
    #
    if args.by_count:
        out.write('sample_count\tnum_of_transition\tnum_of_transversion\tratio\n')
        nSample = getNumOfSamples()
        for i in range(1, 2 * nSample + 1):
            transition = int(getoutput(['vtools', 'select', args.table, '{}={} AND '.format(args.num_field, i) + 
            	"((ref='A' AND alt='G') OR (ref='G' AND alt='A') OR (ref='C' AND alt='T') OR (ref='T' AND alt='C'))",
                '-c']))
            transversion = int(getoutput(['vtools', 'select', args.table, '{}={} AND '.format(args.num_field, i) + 
            	"((ref='A' AND alt='C') OR (ref='C' AND alt='A') OR (ref='G' AND alt='T') OR " + 
                " (ref='T' AND alt='G') OR (ref='A' AND alt='T') OR (ref='T' AND alt='A') OR " +
                " (ref='C' AND alt='G') OR (ref='G' AND alt='C'))",
                '-c']))
            out.write('{}\t{}\t{}\t{:.3f}\n'.format(i, transition, transversion,
                transition / float(transversion) if transversion != 0 else 0))
    else:
        out.write('num_of_transition\tnum_of_transversion\tratio\n')
        transition = int(getoutput(['vtools', 'select', args.table, 
            "(ref='A' AND alt='G') OR (ref='G' AND alt='A') OR (ref='C' AND alt='T') OR (ref='T' AND alt='C')",
            '--output', 'sum({})'.format(args.num_field)]))
        transversion = int(getoutput(['vtools', 'select', args.table, 
            "(ref='A' AND alt='C') OR (ref='C' AND alt='A') OR (ref='G' AND alt='T') OR " + 
            "(ref='T' AND alt='G') OR (ref='A' AND alt='T') OR (ref='T' AND alt='A') OR " +
            "(ref='C' AND alt='G') OR (ref='G' AND alt='C')",
            '--output', 'sum({})'.format(args.num_field)]))
        out.write('{}\t{}\t{:.3f}\n'.format(transition, transversion, 
            transition / float(transversion) if transversion != 0 else 0))
    out.close()
    
#
# Command avg_depth
#
def avgDepthArguments(parser):
    parser.add_argument('-n', '--num_field', required=True,
        help='''Name of the field that holds sample variant count, which is the field name for
            command 'vtools sample_stat --num FIELD_NAME'.''')
    parser.add_argument('-d', '--depth_field', required=True,
        help='''Name of the field that holds average depth of each variant, which is the field
            name for command 'vtools sample_stat --depth FIELD_NAME'.''')
    parser.add_argument('--group_by', nargs='*', default=[],
        help='''Output average depth for each group, for example,
            '--group_by NUM_FIELD to output depth for each sample variant frequency (count).''')
    parser.add_argument('table',
        help='''Variant table for which average depth are calculated.''')

def avgDepth(args):
    out = sys.stdout
    # 
    out.write('{}num_of_variant\taverage_depth\n'.format(''.join([x+'\t' for x in args.group_by])))
    out.write(getoutput(['vtools', 'output', args.table] + args.group_by + 
        ['COUNT(1)', 'SUM({0}*{1})/SUM({0})'.format(args.num_field, args.depth_field)] +
        (['--group_by'] + args.group_by if args.group_by else [])))
    out.close()

#
# Command variant_stat
#
def variantStatArguments(parser):
    parser.add_argument('-s', '--samples', nargs='*', default=[],
        help='''Limiting variants from samples that match conditions that
            use columns shown in command 'vtools show sample' (e.g. 'aff=1',
            'filename like "MG%%"').''')
    parser.add_argument('-g', '--group_by', nargs='*', default=[],
        help='''Group samples by certain conditions such as 'aff=1'. A common
            usage is to group variants by 'filename' and 'sample_name' so that
            variant statistics are outputted for each sample.''')
    parser.add_argument('table', 
        help='''Variant table for which variant metrics are calculated.''')

def variantStat(args):
    out = sys.stdout
    
    # 1) Get samples based on the conditional parameter --samples
    #    Exit the report if there are no samples to analyze.
    out.write('\t'.join(args.group_by) + '\tnum_sample\tnum_snps\tnum_insertions\tnum_deletions\t' +
                'num_substitutions\tmin_insertion_size\tavg_insertion_size\tmax_insertion_size\t' +
                'min_deletion_size\tavg_deletion_size\tmax_deletion_size\n')
    for group, sample_ids in getSamples(args.samples, args.group_by):
        if len(sample_ids) == 0:
            sys.exit('There are no available samples to analyze {}.\n'.format(('given {}'.format(args.samples)) if args.samples else ''))
        #
    	# 2a) Get the counts for snps and substitutions:
    	#     command: vtools select __tmp_vs "ref != '-' and alt != '-' and (length(ref) = 1 or length(alt) = 1)" --samples 'sample_id in $sample_ids' --count
    	num_snps = getoutput(['vtools', 'select', args.table, "ref != '-'", "alt != '-'", "(length(ref) = 1 or length(alt) = 1)",
            '--samples', 'sample_id IN ({})'.format(','.join(sample_ids)), '--count'])
       	num_substitutions = getoutput(['vtools', 'select', args.table, "ref != '-'", "alt != '-'", "(length(ref) > 1 or length(alt) > 1)",
            '--samples', 'sample_id IN ({})'.format(','.join(sample_ids)), '--count'])
    	#
    	# 2b) Get the metrics to characterize the insertions
    	#     command: vtools select variant "ref = '-'" --samples 'sample_id IN $sample_ids' --output 'count(alt)', 'avg(length(alt))' 'min(length(alt))' 'max(length(alt))'
    	num_insertions, avg_insertion_size, min_insertion_size, max_insertion_size = getoutput(
            ['vtools', 'select', args.table, "ref='-'", '--samples', 'sample_id IN ({})'.format(','.join(sample_ids)),
            '--output', 'count(alt)', 'avg(length(alt))', 'min(length(alt))', 'max(length(alt))']).split('\t')
        #    	
    	# 2c) Get the metrics to characterize the deletions
    	#     command: vtools select variant "alt = '-'" --samples 'sample_id IN $sample_ids' --output 'count(ref)', 'avg(length(ref))' 'min(length(ref))' 'max(length(ref))'   	
    	num_deletions, avg_deletion_size, min_deletion_size, max_deletion_size = getoutput(
            ['vtools', 'select', args.table, "alt='-'", '--samples', 'sample_id IN ({})'.format(','.join(sample_ids)),
            '--output', 'count(ref)', 'avg(length(ref))', 'min(length(ref))', 'max(length(ref))']).split('\t') 	
    	#
    	out.write(	'\t'.join(group) + '\t' + 
                    len(sample_ids) + '\t' +
    				num_snps + '\t' + 
    				num_insertions + '\t' + 
    				num_deletions + '\t' +
    				num_substitutions + '\t' +
    				min_insertion_size + '\t' +
    				avg_insertion_size + '\t' +
    				max_insertion_size + '\t' +
    				min_deletion_size + '\t' +
    				avg_deletion_size + '\t' +
    				max_deletion_size + '\n')
    #
    out.close()
	

if __name__ == '__main__':
    #
    master_parser = argparse.ArgumentParser(description='''A collection of functions that
        analyze data using vtools and generate various reports''',
        prog='vtools_report',
        #formatter_class=argparse.RawDescriptionHelpFormatter,
        fromfile_prefix_chars='@',  
        epilog='''Use 'vtools_report cmd -h' for details about each command.
        Please contact Bo Peng (bpeng at mdanderson.org) if you have any question.''')
    master_parser.add_argument('--version', action='version', version='%(prog)s 1.0')
    subparsers = master_parser.add_subparsers(title='Available reports')
    #
    # command trans_ratio
    parser = subparsers.add_parser('trans_ratio',
        help='Transition count, transversion count and transition/transversion ratio',
        description='''This command counts the number of transition (A<->G and C<->T) and
            transversion variants (others) and calculate its ratio. A ratio of 2 is expected
            from a normal sample. If option '--by_count' is specified, it will calculate
            this ratio for variants with different sample allele frequency (count). This
            commands requires a field that stores the sample count for each variant, which
            should be prepared using command 'vtools sample_stat --num FIELD_NAME'.''')
    transRatioArguments(parser)
    addVerbosityArg(parser)
    parser.set_defaults(func=transRatio)
    #
    # command avg_depth
    parser = subparsers.add_parser('avg_depth',
        help='Average depth for each variant, can be divided by sample variant count',
        description='''Command 'vtools sample_stat --depth FIELD' calculates the average
            depth of variants across sample (e.g. average depth of three variants if the 
            variant appears three times in the sample). This command report average depth
            of all variants, or variants divided by sample allele count (output count,
            number of variant, and average depth for count from 1 to 2*#sample). This
            command requires a field that stores the sample count for each variant and
            a field to store average depth of each variant, which should be prepared
            using command 'vtools sample_stat --num FIELD_NAME --depth FIELD_NAME'.''')
    avgDepthArguments(parser)
    addVerbosityArg(parser)
    parser.set_defaults(func=avgDepth)
    #
    # command variant_stat
    parser = subparsers.add_parser('variant_stat',
        help='Reports number of snps, insertions, deletions and substitutions per sample with some size metrics to characterize the indels',
        description='''Command 'vtools variant_counts_per_sample' calculates the number of 
        	snps, insertions, deletions and substitutions per sample with some size metrics to characterize the indels.''')
    variantStatArguments(parser)
    addVerbosityArg(parser)
    parser.set_defaults(func=variantStat)
    # 
    # getting args
    args = master_parser.parse_args()
    # setting global logger
    verbosity = args.verbosity
    logger = getLogger()
    # calling the associated functions
    args.func(args)
